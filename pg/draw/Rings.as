package pg.draw {	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Matrix;		public class Rings extends Sprite {				public const TWO_PI:Number = Math.PI * 2;				public var innerRadius:Number = 100;		public var outerRadius:Number = 110;		public var count:int = 1;		public var tickWidth:Number = .1;		public var tickColor:int = 0;		public var tickAlpha:Number = 1;		public var bmd:BitmapData = new BitmapData(1,1,false, 0);		public var bitmap:Bitmap = new Bitmap(bmd);		public var tickResolution:int = 1;		public var startTick:Number = 0;		public var endTick:Number = -1;		public var skipEveryNthTick:int = 0;		public var canvas:Sprite = new Sprite();				private var tickAngle:Number;		private var tickAngleDelta:Number;		private var tickAngleSegmentDelta:Number;		public function Rings() {			addChild(canvas);		}				public function draw(f_innerRadius:Number = 90, 							  f_outerRadius:Number = 110, 							  f_count:int = 16,							  f_tickWidth:Number = .03, 							  f_tickColor:int = 0, 							  f_tickAlpha:Number = 1,							  f_tickResolution:Number = 2,							  f_startTick:Number = 0,							  f_endTick:Number = -1,							  f_skipEveryNthTick:int = 0):void{			innerRadius = f_innerRadius;			outerRadius = f_outerRadius;			count = f_count;			tickWidth = f_tickWidth;			tickColor = f_tickColor;			tickAlpha = f_tickAlpha;			tickResolution = f_tickResolution;			startTick = f_startTick;			endTick = (f_endTick < f_startTick || f_endTick > count) ? count : f_endTick;			skipEveryNthTick = f_skipEveryNthTick;						tickAngle = TWO_PI / count;			tickAngleDelta = tickAngle * tickWidth;			tickAngleSegmentDelta = tickAngleDelta / tickResolution;						canvas.graphics.clear();			var tick_i:int = -1 + startTick;			var tick_endi:int = endTick;			while(++tick_i < tick_endi){				if (tick_i % skipEveryNthTick != 0){					drawTick(tick_i);				}			}						bmd.dispose();			bmd = new BitmapData(outerRadius << 1, outerRadius << 1, true, 0);			bmd.draw(canvas, new Matrix(1,0,0,1, outerRadius, outerRadius));			bitmap.bitmapData = bmd;			bitmap.x = bitmap.y = -outerRadius;		}				private function drawTick(f_i:int):void{			var tickAngleOffset:Number = f_i * tickAngle;			var points:Vector.<Number> = new Vector.<Number>();			var commands:Vector.<int> = new Vector.<int>();			points.push(Math.cos(tickAngleOffset) * innerRadius,						Math.sin(tickAngleOffset) * innerRadius)			commands.push(1, 2)			var seg_i:int = -1;			var seg_endi:int = tickResolution + 1;			while (++seg_i < seg_endi){				points.push(Math.cos(tickAngleOffset + (tickAngleSegmentDelta * seg_i)) * outerRadius,							Math.sin(tickAngleOffset + (tickAngleSegmentDelta * seg_i)) * outerRadius);				commands.push(2);			}			seg_i = seg_endi;			seg_endi = -1;			while (--seg_i > seg_endi){				points.push(Math.cos(tickAngleOffset + (tickAngleSegmentDelta * seg_i)) * innerRadius,							Math.sin(tickAngleOffset + (tickAngleSegmentDelta * seg_i)) * innerRadius);				commands.push(2);			}			canvas.graphics.beginFill(tickColor, tickAlpha);			canvas.graphics.drawPath(commands, points);		}				public function set useBitmap(f_value:Boolean):void{			if(f_value){				addChild(bitmap);				if (contains(canvas)){					removeChild(canvas);				}			} else {				addChild(canvas);				if (contains(bitmap)){					removeChild(bitmap);				}			}		}				public function get useBitmap():Boolean{			return contains(bitmap);		}	}}