package pg.anim{	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.EventDispatcher; 		public class Tween extends EventDispatcher{		public var target:Object;		private var val:String;		private var startVal:Number = 0;		private var endVal:Number = 0;		private var displacement:Number = 0;		private var inc:int = 0;		private var incLimit:int = 0;		private var incScale:Number = 0;		private var delay:Number = 0;		private var timer:Timer;		private var frameRate:int = 66;		private var chainQueue:Vector.<Array>;		private var callBack:Function;		private var queueDelay:Timer;		private var tweenType:String = "easeInOut";		private var severity:Number = 3;		public var onIncrement:Function = null;				public function Tween(f_target:Object, f_val:String, f_frameRate:Number = 33):void{			chainQueue = new Vector.<Array>();			target = f_target;			val = f_val;			frameRate = f_frameRate;			timer = new Timer(1,1);			queueDelay = new Timer(1, 1);			timer.addEventListener(TimerEvent.TIMER, increment, false, 100, true);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, nextInQueue, false, 100, true);		}				public function goto(f_destination:Number, f_duration:Number, f_tweenType:String = "easeInOut", f_severity:Number = 2, f_callBack:Function = null):void{			callBack = f_callBack;			startVal = target[val];			endVal = f_destination;			tweenType = f_tweenType;			severity = f_severity;			delay = 1000 / frameRate;			inc = 0;			incLimit = (f_duration * frameRate) + 1; //duration  of tween, in number of frames			incScale = 1 / (incLimit); //distance of curve to traverse each frame			displacement = (endVal - startVal);			timer.stop();			timer.reset();			timer.delay = delay;			timer.repeatCount = incLimit;			timer.start();		}				public function addDestination(f_destination:Number, f_duration:Number, f_tweenType:String = "easeOut", f_severity:Number = 2, f_callBack:Function = null, f_delay:Number = 0):void{			var queueItem:Array = new Array();			queueItem.push(f_destination);			queueItem.push(f_duration);			queueItem.push(f_tweenType);			queueItem.push(f_severity);			queueItem.push(f_callBack);			queueItem.push(f_delay * 1000);			chainQueue.push(queueItem);		}				private function nextInQueue(e:TimerEvent):void{			//if delay start timer to hit delayQueueExeution;			if (chainQueue.length >= 1){				if (chainQueue[0][5] > 0){					queueDelay = new Timer(chainQueue[0][5], 1);					queueDelay.addEventListener(TimerEvent.TIMER_COMPLETE, executeQueue, false, 100, true);					queueDelay.start();				} else {					executeQueue();				}			} else {				handleComplete();			}		}				public function executeQueue(e:TimerEvent = null):void{			queueDelay.removeEventListener(TimerEvent.TIMER_COMPLETE, executeQueue);			goto(chainQueue[0][0], chainQueue[0][1], chainQueue[0][2], chainQueue[0][3], chainQueue[0][4]);			chainQueue.shift();		}				private function handleComplete():void{			var te:Event = new Event(Event.COMPLETE);			target[val] = endVal;						dispatchEvent(te);			if (callBack != null){				callBack();			}		}				public function stop():void{			timer.stop();		}				public function set destination(f_val:Number):void{			endVal = f_val;			displacement = (endVal - startVal)		}				public function get destination():Number{			return endVal		}				public function timeShiftTo(f_time:Number):void{			var f_inc:int = (f_time / frameRate)			target[val] = findPosition(f_inc);		}				public function percentShiftTo(f_percent:Number):void{			var f_inc:int = incLimit * f_percent;			target[val] = findPosition(f_inc);		}				private function increment(e:TimerEvent = null):void{			inc++;			target[val] = findPosition(inc);			if (onIncrement !== null){				onIncrement(this);			}		}				private function findPosition(f_inc:int):Number{			var objPosition:Number;			var curvePosition:Number = f_inc * incScale;			objPosition = startVal + (displacement * this[tweenType](curvePosition, severity));			return objPosition;		}				private function easeOut(f_step:Number, f_severity:Number = 2):Number{			var mStep:Number = 1 - f_step;			var val:Number = Math.pow(mStep, f_severity);			return 1 - val;		}				private function easeIn(f_step:Number, f_severity:Number = 2):Number{			var mStep:Number = f_step;			var val:Number = Math.pow(mStep, f_severity);			return val;		}				private function easeInOut(f_step:Number, f_severity:Number = 2):Number{			var val:Number;			if (f_step < 0.5){				val = 0.5 * easeIn(f_step * 2, f_severity);			} else {				val = 0.5 + (0.5 * easeOut((f_step - 0.5) * 2, f_severity));			}			return val;		}				private function backOut(f_step:Number, f_severity:Number = 2):Number{			var mStep:Number = 1 - f_step;			var val:Number = f_severity * Math.pow(mStep, 3) - (f_severity-1) * Math.pow(mStep, 2);			return 1 - val;		}				private function backIn(f_step:Number, f_severity:Number = 2):Number{			var mStep:Number = f_step;			var val:Number = f_severity * Math.pow(mStep, 3) - (f_severity-1) * Math.pow(mStep, 2);			return val;		}				private function backInOut(f_step:Number, f_severity:Number = 2):Number{			var val:Number;			if (f_step < 0.5){				val = 0.5 * backIn(f_step * 2, f_severity);			} else {				val = 0.5 + (0.5 * backOut((f_step - 0.5) * 2, f_severity));			}			return val;		}				private function elasticIn(f_step:Number, f_severity:Number = 2):Number{			var val = 1 - Math.cos((f_severity + .5) * (.5 + (.5 * Math.pow(f_step, 4))) * f_step * Math.PI) * (1 - f_step);			return val;		}	}}