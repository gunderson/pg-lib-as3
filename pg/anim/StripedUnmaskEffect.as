package pg.anim{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Matrix;		import pg.Blit;	public class StripedUnmaskEffect	{		public var bar:Shape;		public var lineWidth:Number;		public var lineHeight:Number;		public var target:DisplayObject;		public var gradientColors:Array = [0x365F91,0xffffff];		public var gradientAlphas:Array = [1,1];		public var gradientRatios:Array = [250,255];						private var _maskTween:Tween;		private var display:Bitmap;		private var _numLines:int;		private var _overrun:Number;		private var _mask:Bitmap;		private var _sequenceOffset:Number;		private var _duration:Number;		private var _position:Number = 0;		private var _separation : Number = 0;		public var callback : Function;				public function StripedUnmaskEffect(f_target:DisplayObject, f_numLines:int, f_duration:Number = 1, f_sequenceOffset:Number = 1, f_overrun:Number = 30, f_separation:Number = 0){			target = f_target;			_sequenceOffset = f_sequenceOffset;			_numLines = f_numLines;			_overrun = f_overrun;			_duration = f_duration;			_separation = f_separation;			lineHeight = Math.ceil(Math.abs((target.height + _separation) / _numLines));			lineWidth = target.width;			_mask = new Bitmap();			_mask.bitmapData = new BitmapData(_overrun + (lineWidth * (_sequenceOffset + 1)), target.height, true, 0);		}				public function destroy():void{			_mask.mask = null;			//if (display && display.parent && display.parent.contains(_mask)) display.parent.removeChild(_mask);						display.bitmapData.dispose();			_mask.bitmapData.dispose();		}				public function play():void{			if (!bar){				makeBars();			}			_maskTween = new Tween(_mask, "x", 30);			_maskTween.goto(display.x, _duration, "easeOut", 1, _callback);		}				public function _callback():void{			if (callback != null){				callback();			}		}				public function makeBars():void{			_position = 0;			var tempCanvas:Sprite = new Sprite();			bar = new Shape();			tempCanvas.addChild(bar);			var m:Matrix = new Matrix();			m.createGradientBox(_mask.width, lineHeight);						bar.graphics.beginGradientFill(				GradientType.LINEAR,				gradientColors, 				gradientAlphas, 				gradientRatios, 				m			);			bar.graphics.drawRect(0,0,_mask.width, lineHeight - _separation);			bar.graphics.endFill();						var i:int = -1;			var endi:int = _numLines;						if (_numLines > 0){				while(++i < endi){					bar.y = lineHeight * i;					bar.x = (-lineWidth * (_sequenceOffset - 1) * (i / _numLines)); 					_mask.bitmapData.draw(tempCanvas);				}			} else {				// bottom up for negative _numlines				endi = _numLines = -_numLines;				while(++i < endi){					bar.y = lineHeight * ((_numLines - i) - 1);					bar.x = (-lineWidth * (_sequenceOffset - 1) * (i / _numLines)); 					_mask.bitmapData.draw(tempCanvas);				}			}						display = Blit.replaceChildWithBitmap(target);			display.cacheAsBitmap = true;									_mask.cacheAsBitmap = true;			_mask.y = display.y;			_mask.x = display.x - _mask.width;			display.parent.addChild(_mask);			_mask.mask = display;		}				public function set position(value:Number):void{			var newX:Number = display.x - (_mask.width * (1 - value));			_mask.x = newX;			_position = value;		}				public function get position():Number{			return _position;		}	}}