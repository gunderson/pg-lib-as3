package pg.anim{	import flash.events.EventDispatcher;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	public class Sequence extends EventDispatcher{		public static var EXECUTE:String = "EXECUTE";		public var chainQueue:Vector.<Object> = new Vector.<Object>;		private var _callback:Function;		private var queueDelay:Timer = new Timer(100, 1);		private var index:int = 0;		public function Sequence(f_callback:Function = null){			_callback = f_callback;		}				public function start():void{			index = 0;			queueDelay.addEventListener(TimerEvent.TIMER_COMPLETE, executeQueue, false, 0, true);			nextInQueue();		}				public function pause():void{			//trace("pg.Sequence :: pause()");			queueDelay.stop();			queueDelay.removeEventListener(TimerEvent.TIMER_COMPLETE, executeQueue);		}				public function resume():void{			queueDelay.start();			queueDelay.addEventListener(TimerEvent.TIMER_COMPLETE, executeQueue, false, 0, true);		}				public function stop():void{			//trace("pg.Sequence :: stop()");			index = 0;			queueDelay.stop();			queueDelay.removeEventListener(TimerEvent.TIMER_COMPLETE, executeQueue);		}				public function append(f_function:Function, f_delay:Number = 0):void{			chainQueue.push({f:f_function, delay:f_delay});		}				private function nextInQueue(e:TimerEvent = null):void{			//trace("pg.Sequence :: chainQueue.length = " + chainQueue.length, index);			if (index < chainQueue.length){				//trace("pg.Sequence :: chainQueue.delay = " + chainQueue[index]['delay']);								//if delay start timer to hit delayQueueExeution;				if (chainQueue[index]['delay'] > 0){					//trace("pg.Sequence :: chainQueue.start() --------");					queueDelay.reset();					queueDelay.delay = 1000 * chainQueue[index]['delay'];					queueDelay.start();				} else {					//trace("pg.Sequence :: executeQueue() --------");					executeQueue();				}			} else {					//trace("pg.Sequence :: handleComplete() --------");				handleComplete();			}		}				public function executeQueue(e:TimerEvent = null):void{			//trace("pg.Sequence :: executeQueue()");						var evt:Event = new Event(EXECUTE);			dispatchEvent(evt);						chainQueue[index++]['f']();			nextInQueue();		}				public function clearQueue():void{			chainQueue = new Vector.<Object>();			index = 0;		}				public function set callback(f_callback:Function):void{			_callback = f_callback;		}				private function handleComplete():void{			//trace("pg.Sequence :: handleComplete()");			queueDelay.removeEventListener(TimerEvent.TIMER_COMPLETE, executeQueue);			var evt:Event = new Event(Event.COMPLETE);			dispatchEvent(evt);			if (_callback != null){				_callback();			}		}	}}