package pg.utils {	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFormat;	public class StringUtils {		public static const PHONE_NUMBER_FORMAT_DOTS:String = "xxx.xxx.xxxx";		public static const PHONE_NUMBER_FORMAT_CLASSIC:String = "(xxx) xxx-xxxx";		public static const PHONE_NUMBER_FORMAT_EURO:String = "xx xx xx xx xx xx";						private static var highlightedStrings : Array;		private static var unHighlightedStrings : Array;		/**		 * Returns everything after the last "." in a string (example: file extension)		 */		public static function fileType(file : String) : String {			var idx : Number = file.lastIndexOf(".");			if (idx == -1)				return "";			else				return file.substr(idx + 1, file.length);		}		/**		 * Make text fit by cutting it off and adding ellipsis to the end		 */		static public function abbreviate(origStr : String, maxLength : Number = 50, moreIndicator : String = '...', splitChar : String = ' ') : String {			if (origStr == null) return "";			if (origStr.length < maxLength) {				return origStr;			}			var str : String = '';			var n : int = 0;			var pieces : Array = origStr.split(splitChar);			// split string into pieces			var charCount : int = String(pieces[n]).length;			// running total of char count			// put pieces back together as long as the charCount doesn't exceed the max length			while (charCount < maxLength && n < pieces.length) {				str += pieces[n] + splitChar;				// put the space back as we add the piece to our new string				charCount += String(pieces[++n]).length + splitChar.length ;				// increase the character count			}			// do extra stuff if we now have an abbreviated string			if (n < pieces.length) {				// trace('[StringUtil.abbreviate] Shortened string to '+ str.length + 'chars : '+str);				// TODO - now that we are AS3, maybe we should use regex for this ?				// remove any chars from the end that are not letters or numbers				var badChars : Array = ['-', '—', ',', '.', ' ', ':', '?', '!', ';', "\n", ' ', String.fromCharCode(10), String.fromCharCode(13)];				while ( badChars.indexOf(str.charAt(str.length - 1)) != -1 ) {					// trace("[StringUtil.abbreviate] Chopping bad char before ellipsis: '"+str.charAt(str.length-1)+"'");					str = str.slice(0, -1);				}				// add an ellipsis to the end				str = trim(str) + moreIndicator;			}			// first word is longer than max length...			if (n == 0) {				str = origStr.slice(0, maxLength) + moreIndicator;			}			return str;		}		/**		 *  Removes whitespace from ends of string		 */		public static function trim(input : String) : String {			return StringUtils.ltrim(StringUtils.rtrim(input));		}		/**		 *  Removes whitespace from the front of a string		 */		public static function ltrim(s : String) : String {			var len : Number = s.length;			for (var i : Number = 0;i < len; i++) if (s.charCodeAt(i) > 32) return s.substring(i);			return "";		}		/**		 *  Removes whitespace from the end of a string		 */		public static function rtrim(s : String) : String {			var len : Number = s.length;			for (var i : Number = len;i > 0; i--) if (s.charCodeAt(i - 1) > 32) return s.substring(0, i);			return "";		}		/**		 * Format a number as a string.		 */		public static function formatNumber(num : Number, decimals : uint = 0, thousandsSeparator : String = ",", decimalSeparator : String = ".") : String {			if (isNaN(num)) return "NaN";			if (num == Number.POSITIVE_INFINITY) return "Infinity";			if (num == Number.NEGATIVE_INFINITY) return "-Infinity";			// First Round the number to the right decimal places			var factor : int = Math.pow(10, decimals);			num = Math.round(num * factor) / factor;			// convert num to string for formatting			// we split it at the decimal point first			var pieces : Array = num.toString().split('.');			var before : Array = String(pieces[0]).split('');			var after : String = pieces[1] != undefined ? pieces[1] : '';			// pad with zeroes after the decimal point			while (after.length < decimals) {				after += '0';			}			// add thousands separator			var len : int = before.length;			var before_formatted : Array = [];			for ( var i : uint = 0;i < len; ++i) {				if (i % 3 == 0 && i != 0) before_formatted.unshift(thousandsSeparator);				before_formatted.unshift(before[len - 1 - i]);			}			var result : String = before_formatted.join('');			if (decimals > 0) {				result += decimalSeparator + after;			}			return result;		}				public static function addLeadingZeros(number:Number, minLength:int = 0):String{			var decimal:String = (number % 1).toString();			decimal = (decimal.length > 1) ? decimal.substr(1) : "";			var integer:String = (number >> 0).toString();			while (integer.length < minLength){				integer = "0".concat(integer);			}			return (decimal == "") ? integer : integer + "." + decimal;		}				public static function addCommas(number : Number) : String {			var negNum : String = "";			if (number < 0) {				negNum = "-";				number = Math.abs(number);			}			var num : String = String(number);			var results : Array = num.split(/\./);			num = results[0];			if (num.length > 3) {				var mod : Number = num.length % 3;				var output : String = num.substr(0, mod);				for (var i : Number = mod; i < num.length; i += 3) {					output += ((mod == 0 && i == 0) ? "" : ",") + num.substr(i, 3);				}				if (results.length > 1) {					if (results[1].length == 1) {						return negNum + output + "." + results[1] + "0";					} else {						return negNum + output + "." + results[1];					}				} else {					return negNum + output;				}			}			if (results.length > 1) {				if (results[1].length == 1) {					return negNum + num + "." + results[1] + "0";				} else {					return negNum + num + "." + results[1];				}			} else {				return negNum + num;			}		}		public static function findAndReplace(str : String, findStr : String, replaceStr : String = "") : String {			return str.split(findStr).join(replaceStr);		}		public static function isValidEmail(email : String) : Boolean {			var emailExpression : RegExp = /^[a-z][\w.-]+@\w[\w.-]+\.[\w.-]*[a-z][a-z]$/i;			return emailExpression.test(email);		}		public static function isValidURL(url : String) : Boolean {			var urlExpression : RegExp = /^http(s)?:\/\/((\d+\.\d+\.\d+\.\d+)|(([\w-]+\.)+([a-z,A-Z][\w-]*)))(:[1-9][0-9]*)?(\/([\w-.\/:%+@&=]+[\w- .\/?:%+@&=]*)?)?(#(.*))?$/i;			return urlExpression.test(url);		}		public static function wrapLinkTextInHTML(str : String) : String {			var result : String = "";			var split : Array = str.split(" ");			var i : int;			for (i = 0; i < split.length; i++) {				if (split[i].substr(0, 7) == "http://" && isValidURL(split[i])) {					split[i] = "<a href='" + split[i] + "'>" + split[i] + "</a>";				}			}			return split.join(" ");		}		public static function makeLinksClickable(tf : TextField, underline : Boolean = true, color : int = 0x0000ff, hoverUnderline : Boolean = true, hoverColor : int = 0xff0000) : void {			tf.htmlText = wrapLinkTextInHTML(tf.htmlText)			underlineLinks(tf, underline, hoverUnderline);			colorLinks(tf, color, hoverColor)		}		public static function underlineLinks(tf : TextField, addUnderlines : Boolean = true, hoverUnderlines : Boolean = true) : void {			var underline : String = ( addUnderlines ) ? "underline" : "none";			var cssClass : String = "a { text-decoration:" + underline + ";}";			underline = ( hoverUnderlines ) ? "underline" : "none";			cssClass += "a:hover { text-decoration:" + underline + ";}"			addToStyleSheet(tf, cssClass);		}		public static function colorLinks(tf : TextField, color : int, hoverColor : int) : void {			var cssClass : String = "a { color:#" + color.toString(16) + ";}";			cssClass += "a:hover { color:#" + hoverColor.toString(16) + ";}"			addToStyleSheet(tf, cssClass);		}		public static function addToFormat(tf : TextField, styles : Object) : void {			var format : TextFormat = tf.getTextFormat();			for (var prop in styles) {				try {					format[prop] = styles[prop]				} catch (e : Error) {					trace("Property " + prop + " does not exist on TextFormat or value " + styles[prop] + " is invalid type.");					trace(e.toString());				}			}			tf.setTextFormat(format);		}		public static function addToStyleSheet(tf : TextField, styles : String) : void {			var ss : StyleSheet;			if (tf.styleSheet) {				ss = tf.styleSheet;			} else {				ss = new StyleSheet();			}			ss.parseCSS(styles);			tf.styleSheet = ss;		}		public static function highlightString(tf : TextField, str : String, textColor : int = 0, bold : Boolean = false, italic : Boolean = false) : int {			if (!unHighlightedStrings) {				unHighlightedStrings = new Array();				highlightedStrings = new Array();			}			var cssClassName : String = "highlightedstring" + highlightedStrings.length;			var cssClass : String = "." + cssClassName + " {color:#" + textColor.toString(16) + ";";			if (bold) {				cssClass += "font-weight:bold;"			} else {				cssClass += "font-weight:normal;"			}			if (italic) {				cssClass += "font-style:italic;"			} else {				cssClass += "font-style:normal;"			}			cssClass += "}";			var styledString : String = "<span class=\"" + cssClassName + "\">" + str + "</span>";			tf.htmlText = findAndReplace(tf.htmlText, str, styledString);			addToStyleSheet(tf, cssClass);			unHighlightedStrings.push(str);			highlightedStrings.push(styledString);			return (unHighlightedStrings.length - 1);		}		public static function unHighlightString(tf : TextField, id : int) : void {			tf.htmlText = findAndReplace(tf.htmlText, highlightedStrings[id], unHighlightedStrings[id]);		}				public static function highlightSubString(tf : TextField, begin : int, end : int, textColor : int = 0, bold : Boolean = false, italic : Boolean = false) : int {			begin = ( begin < 0 ) ? tf.text.length + (begin % tf.text.length) : begin;			end = ( end < 0 ) ? tf.text.length + (end % tf.text.length) : end;				if (end < begin) {				return NaN;			}			var str : String = tf.text.substring(begin, end);			var id : int = highlightString(tf, str, textColor, bold, italic)			return id;		}				public static function highlightSubStr(tf : TextField, begin : int, length : int, textColor : int = 0, bold : Boolean = false, italic : Boolean = false) : int {			begin = ( begin < 0 ) ? tf.text.length + (begin % tf.text.length) : begin;			var end:int = ( begin + length < tf.text.length) ? begin + length : tf.text.length - 1;				var str : String = tf.text.substring(begin, end);			if (end < begin) {				str = "πå†®ˆö˚";			}			var id : int = highlightString(tf, str, textColor, bold, italic)			return id;		}				public static function formatPhoneNumber(phoneNumber:String, style:String):String{			phoneNumber = StringUtils.findAndReplace(phoneNumber, "(");			phoneNumber = StringUtils.findAndReplace(phoneNumber, ")");			phoneNumber = StringUtils.findAndReplace(phoneNumber, "-");			phoneNumber = StringUtils.findAndReplace(phoneNumber, " ");			phoneNumber = StringUtils.findAndReplace(phoneNumber, ".");			phoneNumber = StringUtils.findAndReplace(phoneNumber, "+");						if (phoneNumber.length > 10) phoneNumber = phoneNumber.substr(-10);			if (phoneNumber.length == 0) return "";						switch(style){				case StringUtils.PHONE_NUMBER_FORMAT_CLASSIC:					phoneNumber = "(" + phoneNumber.substr(0,3) + ") " + phoneNumber.substr(3,3) + "-" + phoneNumber.substr(6,4);					break;				case StringUtils.PHONE_NUMBER_FORMAT_DOTS:					phoneNumber = phoneNumber.substr(0,3) + "." + phoneNumber.substr(3,3) + "." + phoneNumber.substr(6,4);					break;				case StringUtils.PHONE_NUMBER_FORMAT_EURO:					phoneNumber = phoneNumber.substr(0,2) + " " + phoneNumber.substr(2,2) + " " + phoneNumber.substr(4,2) + " " + phoneNumber.substr(6,2) + " " + phoneNumber.substr(8,2);					break;			}			return phoneNumber;		}	}}